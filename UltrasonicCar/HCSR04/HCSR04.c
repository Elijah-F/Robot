



/******************************************************************************
超声波扫描程序:
	定时器0每10ms产生一次中断,给Triq引脚10us的高电平触发超声波(每次定时器0只能触发一个超声波,四个超声波需要四次定时器中断)
	检测Echo(或门出端)是否为高电平从而判断是否检测到物体,为检测到直接退出,检测到了记录此时定时器的值(上升沿的值),并开启外部中断0
	如果10ms内触发了外部中断0(10ms内遇到下降沿),执行中断服务函数,记录下降沿时定时器的值,通过两次定时器值做差得到距离
	如果10ms内没有触发外部中断(没有下降沿,一直是高电平),说明距离已经超出检测最大距离,将distance[i]设置为溢出值

	超声波的Triq引脚和Echo引脚分别与单片机IO口连接,所有Echo引脚通过一个多输入或门,输出与P3^2相连,从而实现利用一个中断接收多个超声波。
	需要注意的是：当有一个超声波检测到的距离过远时(都轮到检测下一个超声波模块了这个模块高电平还没结束),此时在或门的作用下P3^2引脚一直为高
	会影响其他超声波的正常工作(中断不能触发,因为下降沿触发中断),因此每次开启超声波的时候需要判断一下上一次的超声波Echo引脚是否为高
	是则拉低,并且给其距离赋溢出值(说明距离太远超出检测范围)
*******************************************************************************/



#include "HCSR04.h"
#include "intrins.h"
#include "Motor.h"
#include "uart.h"
/*超声波Triq引脚定义,触发测距引脚*/
sbit Triq1=P2^0;	//前左
sbit Triq2=P2^1;	//前右
sbit Triq3=P2^2;	//中后	 
sbit Triq4=P2^3;	//前中
/*超声波Echo引脚定义*/
sbit Echo1=P2^4;
sbit Echo2=P2^5;
sbit Echo3=P2^6;
sbit Echo4=P2^7;

sbit Echo=P3^2;		//或门输出端引脚定义,对应外部中断0
sbit LED=P1^7;		//触发中断 检测到物体状态指示灯
unsigned int Dis_H=0,Dis_L=0;		//Dis_L-高电平开始时定时器的值、Dis_H-高点平结束时定时器的值
bit HC_EN=0;						//超声波状态标志位-标志超声波波形高低点平状态:1代表高电平
unsigned int HC_counter=0; 			//超声波代号:0~3分别表示四个超声波
unsigned int distance[4]=30000;		//前方障碍物距离存放数组,30000为溢出值(最大检测距离)(并没有真正计算距离,只是用高电平的定时器记录值表示距离即可)


/*
* 超声波启动脉冲，10us左右
* _nop_()包含在intrins.h中  1个机械周期=12个时钟周期   t=12*(1/f)
* 12MHz 晶振刚好为1us     
*/
void HC_delay(void)					//超声波启动脉冲，10us左右
{
	_nop_(); _nop_(); 
    _nop_(); _nop_(); 
    _nop_(); _nop_(); 
    _nop_(); _nop_(); 
    _nop_(); _nop_(); 
	_nop_(); _nop_(); 
    _nop_(); _nop_(); 
    _nop_(); _nop_();
	_nop_(); _nop_(); 
    _nop_(); _nop_(); 
}

void INT0_Init()
{
	IT0=1;			//外部中断0设置为下降沿触发(下降沿触发很重要,因为当超声波高电平的时间决定了物体的距离远近,下降沿然后记录Dis_H的值是高电平结束的值)
  	EX0=1;			//外部中断0使能
	PX0=0;			//将外部中断0定义为低优先级
}

void InitTimer0(void)
{
	TMOD |= 0x01;	//定时方式寄存器:用定时器0的方式1(16位定时器)
	TH0 = 0xDC;		//11.0592M晶振是10ms 溢出后TF1位被置1并且申请中断,进入中断后硬件自动清零
	TL0 = 0x00;	
	EA = 1;			
	ET0 = 1;		//定时器0使能
	TR0 = 1;		//置1:启动定时器1	
	PT0 = 0;		//将定时器0中断定义为低优先级中断
}
/*
*	每10ms溢出一次,执行一次定时器0的中断函数
*	函数功能:
* 		用HC_counter表示操作的是第几个超声波(0 1 2 3)
*		并执行HC_start函数	
*/
void Timer0Interrupt(void) interrupt 1
{
	TH0 = 0xDC;
  	TL0 = 0x00;
	HC_counter++;
	if(HC_counter>3)
		HC_counter=0;
	HC_start(HC_counter);
}



/*
* 	超声波波形通过或门统一交给P3^2外部中断0,触发中断服务函数
*	函数功能:
*		计算超声波检测到的物体距离	
*/
int flag =0;
void INT_0() interrupt 0
{
	EX0=0; 				//进来先关闭外部中断0,否则可能造成二次触发中断
	Dis_H = TH0 << 8;		
	Dis_H += TL0;		//第二次定时器值记录(高电平下降沿时记录),第一次是在高电平上升沿时记录
	_nop_(); 
  	_nop_(); 
  	_nop_();
	//二次判断P2的高四个引脚(判断超声波波形的四个引脚)是否为高电平,如果不是说明误操作了,直接退出
	//如果经常误操作加大此处的延时时间
	if(P2&0xf0) {
		EX0=1;
		return;
	}
	//超声波波形高电平时间只记录了不到200个数,时间太短认为是异常,不进行操作
	//大于200才被认为是正常的接收到了超声波高电平,HC_EN==1表示超声波为高电平
	if(HC_EN && (Dis_H - Dis_L) > 200)  	
	{
		//二次判断超声波是否为高电平
		if(HC_EN)
		{	
			//上升沿和下降沿两次记录的值作差的值表示距离
			distance[HC_counter]=(Dis_H - Dis_L);
			HC_EN=0;
		}
		else
		{
			distance[HC_counter]=30000;
		}
		/*超声波调试区
		if(distance[HC_counter]<DISTANCE)
		printf("%d:%d\n",HC_counter,distance[HC_counter]);
		*/
		if (flag > 30) {
			flag = 0;
		}
		
		LED = ~LED;
	}
}


/*
* 通过定时器 n  从0到3
* 发送触发信号 接收到下降沿记录值  
*/
void HC_start(unsigned char n)    
{
	unsigned int i=500; 		//等待超声波高电平超时时间
	EX0=0;						//关闭外部中断0,当我已经检测到高电平后再开启外部中断0,从而下降沿触发
	if(P2&0xf0)					//有超声波是高电平表示上次的距离太远了,超出了最大检测距离
	{
		if(Echo1)distance[0]=30000;	//溢出值
		if(Echo2)distance[1]=30000;
		if(Echo3)distance[2]=30000;
		if(Echo4)distance[3]=30000;
		P2&=0x0f;					//强行拉低超声波Echo引脚
	}

	switch(n)
	{
		case 0:	
			Echo1=1;
			Triq1=1;
			HC_delay();	  //通过Triq1引脚触发超声波模块测距
			Triq1=0;
			break;
		case 1:
			Echo2=1;
			Triq2=1;
			HC_delay();
			Triq2=0;
			break;
		case 2:
			Echo3=1;
			Triq3=1;
			HC_delay();
			Triq3=0;
			break;
		case 3:
			Echo4=1;
			Triq4=1;
			HC_delay();
			Triq4=0;
			break;
		default:break;		
	}	
	_nop_(); 


	//触发测距后,等待超声波标志位使能(超声波波形变为高电平)
	//退出循环时如果i==0说明未等待成功,否则说明等待到了高电平(超声波检测到有物体) 
	while(Echo==0 && i--);

	if(i != 0)
	{
		//等待到了高电平,也就是捕捉到了上升沿,记录此时定时器的值并HC_EN记录为1表示超声波波形为高电平
		//开启外部中断,外部中断会在高电平跳变为低电平的时候触发中断
		Dis_L = TH0 << 8;
		Dis_L += TL0;
		HC_EN = 1;
		EX0 =1;
	}
	else 
	{
		//没有等待到高电平(未检测到物体),退出
		HC_EN=0;
	}	
}








